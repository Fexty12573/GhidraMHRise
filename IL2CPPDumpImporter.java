//Imports SDK dumps generated by REFramework and uses it to annotate the program.
//@author Fexty
//@category Annotation
//@keybinding
//@menupath
//@toolbar

import ghidra.app.script.GhidraScript;
import ghidra.program.model.address.AddressFactory;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.*;
import ghidra.program.model.symbol.Namespace;
import ghidra.program.model.symbol.SourceType;
import ghidra.program.model.symbol.SymbolTable;
import org.json.*;
import org.python.antlr.op.Param;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;
import java.util.stream.Collectors;

public class IL2CPPDumpImporter extends GhidraScript {

	private static final String CLASS_FILTER = "snow.data.DangoMixData"; // Set to null or "" for no filter.
	private static final boolean LOG_CLASSES = true; // Whether to log which class is being added.

	static public FunctionManager functionManager;
	static public DataTypeManager mainTypeManager;
	static public FileDataTypeManager typeManager;
	static public AddressFactory addressFactory;
	static public SymbolTable symbolTable;
	static public CategoryPath category = new CategoryPath("/IL2CPP_Types");
	static public HashMap<String, DataType> valueTypes;
	private JSONObject il2cppDump;

	private int classesAdded;
	private int classesToAdd;

	private HashMap<String, RETypeDefinition> typeMap;

	@Override
	protected void run() throws Exception {
		initialize();
		importIL2CPPDump();
	}

	private void initialize() {
		functionManager = currentProgram.getFunctionManager();
		mainTypeManager = currentProgram.getDataTypeManager();
		addressFactory = currentProgram.getAddressFactory();
		symbolTable = currentProgram.getSymbolTable();
		typeMap = new HashMap<>();

		try {
			File file = Path.of("IL2CPP_Types.gdt").toFile();
			if (file.exists()) {
				println("FILE EXISTS");
				typeManager = FileDataTypeManager.openFileArchive(file, true);
			} else {
				typeManager = FileDataTypeManager.createFileArchive(file);
			}
		} catch (IOException e) {
			println(e.getMessage());
		}

		int id = typeManager.startTransaction("add basic types");
		final var uint8_t = typeManager.addDataType(new TypedefDataType("uint8_t", mainTypeManager.getDataType("/uchar")), DataTypeConflictHandler.REPLACE_HANDLER);
		final var int8_t = typeManager.addDataType(new TypedefDataType("int8_t", mainTypeManager.getDataType("/char")), DataTypeConflictHandler.REPLACE_HANDLER);
		final var uint16_t = typeManager.addDataType(new TypedefDataType("uint16_t", mainTypeManager.getDataType("/ushort")), DataTypeConflictHandler.REPLACE_HANDLER);
		final var int16_t = typeManager.addDataType(new TypedefDataType("int16_t", mainTypeManager.getDataType("/short")), DataTypeConflictHandler.REPLACE_HANDLER);
		final var uint32_t = typeManager.addDataType(new TypedefDataType("uint32_t", mainTypeManager.getDataType("/uint")), DataTypeConflictHandler.REPLACE_HANDLER);
		final var int32_t = typeManager.addDataType(new TypedefDataType("int32_t", mainTypeManager.getDataType("/int")), DataTypeConflictHandler.REPLACE_HANDLER);
		final var uint64_t = typeManager.addDataType(new TypedefDataType("uint64_t", mainTypeManager.getDataType("/ulonglong")), DataTypeConflictHandler.REPLACE_HANDLER);
		final var int64_t = typeManager.addDataType(new TypedefDataType("int64_t", mainTypeManager.getDataType("/longlong")), DataTypeConflictHandler.REPLACE_HANDLER);
		final var uintptr_t = typeManager.addDataType(new TypedefDataType("uintptr_t", mainTypeManager.getDataType("/ulonglong")), DataTypeConflictHandler.REPLACE_HANDLER);
		final var intptr_t = typeManager.addDataType(new TypedefDataType("intptr_t", mainTypeManager.getDataType("/ulonglong")), DataTypeConflictHandler.REPLACE_HANDLER);
		typeManager.endTransaction(id, true);

		valueTypes = new HashMap<>();
		valueTypes.put("System.Single", mainTypeManager.getDataType("/float"));
		valueTypes.put("System.Double", mainTypeManager.getDataType("/double"));
		valueTypes.put("System.Void", mainTypeManager.getDataType("/void"));
		valueTypes.put("System.UInt8", uint8_t);
		valueTypes.put("System.UInt16", uint16_t);
		valueTypes.put("System.UInt32", uint32_t);
		valueTypes.put("System.UInt64", uint64_t);
		valueTypes.put("System.Int8", int8_t);
		valueTypes.put("System.Int16", int16_t);
		valueTypes.put("System.Int32", int32_t);
		valueTypes.put("System.Int64", int64_t);
		valueTypes.put("System.SByte", mainTypeManager.getDataType("/byte"));
		valueTypes.put("System.Byte", mainTypeManager.getDataType("/byte"));
		valueTypes.put("System.UByte", mainTypeManager.getDataType("/uchar"));
		valueTypes.put("System.UIntPtr", uintptr_t);
		valueTypes.put("System.IntPtr", intptr_t);
		valueTypes.put("System.Char", mainTypeManager.getDataType("/char"));
		valueTypes.put("System.UChar", mainTypeManager.getDataType("/uchar"));
		valueTypes.put("System.Void*", mainTypeManager.getDataType("/void *"));
		valueTypes.put("System.Boolean", mainTypeManager.getDataType("/bool"));
		valueTypes.put("System.TypeCode", mainTypeManager.getDataType("/int"));
		valueTypes.put("System.DateTime", uint64_t);
		valueTypes.put("System.TimeSpan", int64_t);
		valueTypes.put("s8", int8_t);
		valueTypes.put("u8", uint8_t);
		valueTypes.put("s16", int16_t);
		valueTypes.put("u16", uint16_t);
		valueTypes.put("s32", int32_t);
		valueTypes.put("u32", uint32_t);
		valueTypes.put("s64", int64_t);
		valueTypes.put("u64", uint64_t);
		

		// TODO: Handle geometric engine types like via.vec4 or via.mat4.
		// They could be represented as simple float arrays or by explicitly creating a type for the beforehand.
	}

	private void importIL2CPPDump() {
		try {
			File file = askFile("Select IL2CPP Dump", "Open");
			il2cppDump = new JSONObject(Files.readString(file.toPath()));
		} catch (Exception e) {
			println(e.getMessage());
			return;
		}
		println("JSON Loaded");

		// Add all already existing types to the type map to avoid adding types that have already been added to the archive
		for (var iter = typeManager.getAllDataTypes(); iter.hasNext();) {
			DataType dt = iter.next();
			String name = dt.getDisplayName();

			// Only add IL2CPP Classes and exclude pointers
			if (name.contains(".") && !name.contains("*")) {
				classesAdded++;

				var def = new RETypeDefinition(name, il2cppDump.getJSONObject(name));
				def.setDataType(dt);

				typeMap.put(name, def);
			}
		}
		println("already parsed types mapped");

		var keys = il2cppDump.keySet();
		if (CLASS_FILTER == null || CLASS_FILTER.isEmpty()) {
			classesToAdd = keys.size();

			// Add all types + Methods to ghidra
			for (var key : keys) {
				parseClass(key);

				try {
					// Save during each iteration to allow cancelling and resuming without losing much progress
					// Might have considerable impact on performance
					typeManager.save();
				} catch (IOException e) {
					println(e.getMessage());
				}
			}
		} else {
			Set<String> filtered = keys.stream().filter((name) -> name.startsWith(CLASS_FILTER)).collect(Collectors.toSet());
			classesToAdd = filtered.size();

			for (var key : filtered) {
				parseClass(key);

				try {
					typeManager.save();
				} catch (IOException e) {
					println(e.getMessage());
				}
			}
		}

		try {
			typeManager.save();
		} catch (IOException e) {
			println(e.getMessage());
		}

		il2cppDump = null;
		System.gc();
	}

	public boolean isValueType(String name) {
		return valueTypes.containsKey(name);
	}

	public DataType getValueType(String objectName) {
		return valueTypes.get(objectName);
	}

	private DataType getValueTypeOrType(String name) {
		// Top-level types start with a '/', should only occur for built-in types.
		if (name.charAt(0) == '/') {
			var dt = mainTypeManager.getDataType(name);
			if (dt == null) {
				println("Failed to find datatype:" + name);
			}
			return dt;
		}

		if (valueTypes.containsKey(name)) {
			return valueTypes.get(name);
		}

		// Type is not a ValueType
		RETypeDefinition type = typeMap.getOrDefault(name, null);
		if (type == null) {
			parseClass(name);
			var dt = typeMap.get(name).getDataType();
			if (dt == null) {
				// Should only happen in case an Exception is thrown in parseClass
				println("dt is null for " + name + " after parsing");
			}

			return dt;
		}

		DataType dt = type.getDataType();
		if (dt == null) {
			// Should technically never happen
			println("dt is null for " + name);
		}

		return dt;
	}

	private Namespace getOrCreateNamespace(String name) {
		// Packed into a function because I hate java's enforced exception handling or continued propagating.
		try{
			return symbolTable.getOrCreateNameSpace(currentProgram.getGlobalNamespace(), name, SourceType.IMPORTED);
		} catch (Exception e) {
			println(e.getMessage());
			return null;
		}
	}

	private void parseClass(String name) {
		if (typeMap.containsKey(name)) {
			return;
		}

		// Not actually an accurate display of progress if a filter is used but at least gives me an idea of how much
		// was already completed lol.
		println(String.format("(%d/%d) Adding methods for %s", classesAdded, classesToAdd, name));
		classesAdded++;

		// Create type definition from JSON object for later reference and faster access to data
		RETypeDefinition definition = new RETypeDefinition(name, il2cppDump.getJSONObject(name));
		typeMap.put(name, definition);

		// Create ghidra type from type definition
		StructureDataType type = new StructureDataType(name, definition.getSize());
		// Store ghidra datatype for later use
		definition.setDataType(type);

		// Parse parent class before parsing current class
		if (definition.hasParent()) {

			// Enum types should be added as an actual enum, not a structure. They DO have a structure
			// representation however it is only very rarely used so I don't see the point of adding that.
			// Also, this 'if' is inside the hasParent 'if' because enums always have System.Enum as parent
			if (definition.isEnum()) {
				var enumType = new EnumDataType(name, getValueType(definition.getUnderlyingType()).getLength());

				for (var field : definition.getFields()) {
					try {
						enumType.add(field.getName(), field.getDefaultValue());
					} catch (IllegalArgumentException e) {
						println(e.getMessage());
						println(e.getStackTrace()[0].toString());
					}

				}

				definition.size = enumType.getLength();

				// Overwrite ghidra type of type definition
				definition.setDataType(enumType);
			}

			parseClass(definition.getParent());
		}

		// Add all fields to the class
		addFieldsOfClassToType(definition, type);

		// Add all methods
		if (definition.hasMethods()) {
			for (var method : definition.getMethods()) {
				parseMethod(method, name);
			}
		}

		// Add type to the archive
		int id = typeManager.startTransaction("Add New IL2CPP_Type");
		typeManager.addDataType(definition.getDataType(), DataTypeConflictHandler.REPLACE_HANDLER);
		typeManager.addDataType(definition.getPointerTo(), DataTypeConflictHandler.REPLACE_HANDLER);
		typeManager.endTransaction(id, true);

		// Keeps memory usage a bit lower, but has considerable impact on performance, would not recommend.
		// Set JVM Memory lower instead if necessary
		// System.gc();
	}

	private void parseMethod(REMethod method, String parent) {
		if (method.getAddress() != 0) {
			// Get the return type
			var retType = getValueTypeOrType(method.getReturnType());
			if (retType == null) {
				// Should generally not happen
				println("retType is null for " + method.getReturnType());
				return;
			}

			// Methods that have a ValueType as return type that is bigger than sizeof(void*) do not actually return it,
			// but instead take it as an out parameter as the very first parameter. (Before thread context and 'this')
			if (isValueType(method.getReturnType()) && retType.getLength() > 8) {
				method.setReturnAsOutParameter();
			}

			var address = addressFactory.getAddress(method.getAddressString());
			Function existing = functionManager.getFunctionAt(address);
			Function function = null;

			if (existing != null) {
				function = existing;

				// If the function doesn't have a parent namespace then it is most likely auto-created by the
				// ghidra analyzer. As such we should change the name
				if (existing.getParentNamespace() == null) {
					try {
						existing.setName(method.getName(), SourceType.IMPORTED);
						existing.setParentNamespace(getOrCreateNamespace(parent));
					} catch(Exception e) {
						println(e.getMessage());
					}

				} else {
					// If the function already has a parent namespace then we assume that the function was labelled
					// either by a previous run of the script, or the user explicitly named it. In either case
					// the function is not renamed and a label is placed instead to preserve existing naming.
					try {
						var label = createLabel(address, method.getName(), false);
						label.setNamespace(getOrCreateNamespace(parent));
					} catch (Exception e) {
						println(e.getMessage());
					}
				}
			} else {
				// If the function does not yet exist then we try to create it and then rename it. I don't know how this
				// behaves if the bytes at this location have not yet been disassembled.
				try {
					function = createFunction(address, method.getName());
					function.setParentNamespace(getOrCreateNamespace(parent));
				} catch (Exception e) {
					println(e.getMessage());
				}
			}

			// Add all parameters to the function. Code is not complete because there are a million exceptions to
			// consider where certain parameters do not exist or others exist even tho the dump does not specify them.
			// As a general rule tho:
			// - The engine conforms to the x64 calling convention so parameters are RCX, RDX, R8, R9, Stack...
			// - (Basically) all methods take a thread context as their first argument in RCX (or RDX, exception below)
			// - If a method has the 'HasThis' flag, then it takes a 'this' parameter in RDX (or R8, ...)
			// - All parameters listed by the dump follow after these 2 in R8/R9 and then on the stack starting at 0x28
			// - The size of an argument on the stack is at most 8 bytes. Types with size greater 8 are passed as a
			// pointer.
			// - Stack arguments are always 8 byte aligned regardless of the size of the type. So +0x28, +0x30, +0x38...
			// - If a function has a return type which is a ValueType and its size is greater than sizeof(void*) then
			// this parameter is passed as a pointer in RCX *always*. It is also returned as a pointer
			// I believe there are also some types that aren't explicitly ValueTypes but still adhere to this behavior.
			// - There might be some more intricacies that I have missed...
			if (function != null) {

				// Check if return type exists already in the type map, parse it otherwise
				if (!typeMap.containsKey(method.getReturnType())) {
					parseClass(method.getReturnType());
				}

				// Change the return type of the function
				try {
					function.setReturnType(getValueTypeOrType(method.getReturnType()), SourceType.IMPORTED);
				} catch (Exception e) {
					println(e.getMessage());
				}

				var params = method.getParameters();
				var funcParams = new ArrayList<ParameterImpl>();

				try {
					var ret = new ReturnParameterImpl(retType, currentProgram);

					for (var param : params) {
						// (Hopefully) let ghidra automatically determine the register/stack offset of the parameter
						funcParams.add(new ParameterImpl(param.name, getValueTypeOrType(param.type), currentProgram));
					}

					if (method.implFlags.contains("HasThis") && params.size() > 1) {
						funcParams.set(1, new ParameterImpl(params.get(1).name, getValueTypeOrType(parent), currentProgram));
					}
					// Using this function as Function.addParameter is deprecated. This also makes things easier as
					// ghidra tries to determine Register and stack offset by itself. Might have to change if this
					// doesn't work.
					function.updateFunction("__fastcall", ret, funcParams, Function.FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true, SourceType.IMPORTED);
				} catch (Exception e) {
					println(e.getMessage());
				}
			}
		}
	}

	private void addFieldsOfClassToType(RETypeDefinition definition, StructureDataType type) {
		if (definition.hasFields()) {
			try {
				addFieldsToType(definition.getFields(), type);
			} catch (Exception e) {
				println("Exception adding fields for " + definition.name);
				println(e.toString());
				if (e.getStackTrace().length > 0) {
					println(e.getStackTrace()[0].toString());
				}
			}
		}

		// The IL2CPP Dump only lists fields of the current class, it doesn't list inherited fields of parent classes
		// so we need to explicitly handle those.
		if (definition.hasParent()) {
			String parent = definition.getParent();
			RETypeDefinition parentDefinition = typeMap.getOrDefault(parent, null);
			type.replaceAtOffset(0, getValueTypeOrType(parent), parentDefinition.size, "__base_" + parent, "BASE_CLASS");
			// if (parentDefinition != null) {
			// 	addFieldsOfClassToType(parentDefinition, type);
			// } else {
			// 	parseClass(parent);
			// 	addFieldsOfClassToType(typeMap.get(parent), type);
			// }
		}
	}

	private void addFieldsToType(ArrayList<REField> fields, StructureDataType type) throws Exception {
		for (var field : fields) {
			if (!field.isStatic()) {
				String typeName = field.getType();

				RETypeDefinition fieldType = typeMap.getOrDefault(typeName, null);
				if (fieldType == null) {
					parseClass(typeName);
					fieldType = typeMap.get(typeName);
				}

				// We need to handle Enums, ValueTypes, and all other types separately.
				// Enums are the only non-ValueTypes are usually passed by value and stored in their value form too.
				// ValueTypes are stored in value form so we use "built-in" ghidra types to simplify things.
				// All other types are stored on the heap and are only accessed via pointers.
				if (fieldType.isEnum()) {
					type.replaceAtOffset(field.getOffsetFromBase(), fieldType.getDataType(), fieldType.getSize(), field.getName(), field.getFlags());
				} else if (isValueType(typeName)) {
					type.replaceAtOffset(field.getOffsetFromBase(), getValueType(typeName), fieldType.getSize(), field.getName(), field.getFlags());
				} else {
					type.replaceAtOffset(field.getOffsetFromBase(), fieldType.getPointerTo(), fieldType.getSize(), field.getName(), field.getFlags());
				}
			}
		}
	}

	private static class REMethod {
		public static class Parameter {
			public String name;
			public String type;

			public Parameter(String n, String t) {
				name = n;
				type = t;
			}
		}

		private final String name;
		private final String flags;
		private final long address;
		private final String addressString;
		private final int id;
		private final int invokeId;
		private final String implFlags;
		private final ArrayList<Parameter> parameters;
		private final String returnType;

		REMethod(String name, JSONObject method) {
			flags = method.getString("flags");
			addressString = method.getString("function");
			address = Long.parseLong(addressString, 16);
			id = method.getInt("id");
			invokeId = method.getInt("invoke_id");
			if (method.has("impl_flags")) {
				implFlags = method.getString("impl_flags");
			} else {
				implFlags = "";
			}

			// Since method names are stored with [Name][ID] we remove the ID to avoid confusing names in ghidra.
			// Also constructor names always start with a '.' so we remove that also to avoid 'Namespace::.Name'
			this.name = (name.startsWith(".") ? name.substring(1) : name).substring(0, name.indexOf(Integer.toString(id)));

			parameters = new ArrayList<>();
			if (method.has("params")) {
				var params = method.getJSONArray("params");
				for (int i = 0; i < params.length(); i++) {
					var param = params.getJSONObject(i);
					// TODO: Handle possible parameter flags
					parameters.add(new Parameter(param.getString("name"), param.getString("type")));
				}
			}

			if (implFlags.contains("HasThis")) {
				parameters.add(0, new Parameter("this", "/void *"));
			}

			// Methods always take the thread context as their first parameter
			parameters.add(0, new Parameter("vmctx", "/void *"));

			returnType = method.getJSONObject("returns").getString("type");
		}

		public String getName() {
			return name;
		}

		public String getFullName(String parentClass) {
			return parentClass + "." + name;
		}

		public String getFlags() {
			return flags;
		}

		public long getAddress() {
			return address;
		}

		public String getAddressString() {
			return addressString;
		}

		public int getId() {
			return id;
		}

		public int getInvokeId() {
			return invokeId;
		}

		public String getImplFlags() {
			return implFlags;
		}

		public ArrayList<Parameter> getParameters() {
			return parameters;
		}

		public void setReturnAsOutParameter() {
			// Out parameters are always in RCX
			parameters.add(0, new Parameter("out", returnType + " *"));
		}

		public String getReturnType() {
			return returnType;
		}

		public Parameter getParameter(int index) {
			return parameters.get(index);
		}
	}

	private static class REField {
		private final String flags;
		private final int id;
		private final int offsetFromBase;
		private final int offsetFromFieldPtr;
		private final String type;
		private final String name;
		private final int defaultValue;

		public REField(String name, JSONObject field) {
			flags = field.getString("flags");
			id = field.getInt("id");
			offsetFromBase = Integer.parseInt(field.getString("offset_from_base").substring(2), 16);

			// Only ever used for ValueTypes, can ignore for the most part. Kept it here for completeness' sake.
			offsetFromFieldPtr = Integer.parseInt(field.getString("offset_from_fieldptr").substring(2), 16);
			type = field.getString("type");

			// Only really used for enum members
			defaultValue = field.optInt("default", 0);
			this.name = name;
		}

		public String getFlags() {
			return flags;
		}

		public boolean isStatic() {
			return flags.contains("Static");
		}

		public int getId() {
			return id;
		}

		public int getOffsetFromBase() {
			return offsetFromBase;
		}

		public int getOffsetFromFieldPtr() {
			return offsetFromFieldPtr;
		}

		public String getType() {
			return type;
		}

		public String getName() {
			return name;
		}

		public int getDefaultValue() {
			return defaultValue;
		}
	}

	private static class RETypeDefinition {
		private final String name;
		private int size;
		private final String parent;
		private final ArrayList<REField> fields;
		private final ArrayList<REMethod> methods;
		private final boolean isValueType;
		private final boolean isEnum;
		private final String underlyingType;

		private DataType dataType;
		private PointerDataType pointerTo;

		public RETypeDefinition(String className, JSONObject object) {
			name = className;
			size = Integer.parseInt(object.getString("size"), 16);
			parent = object.has("parent") ? object.getString("parent") : "";
			fields = new ArrayList<>();
			methods = new ArrayList<>();

			if (parent.equals("System.ValueType")) {
				isValueType = true;
				isEnum = false;
			} else if (parent.equals("System.Enum")) {
				isValueType = false;
				isEnum = true;
			} else {
				isValueType = false;
				isEnum = false;
			}

			if (isEnum) {
				// Get the enums underlying type
				if (object.has("reflection_properties")) {
					underlyingType = object.getJSONObject("reflection_properties").getJSONObject("value__").getString("type");
				} else {
					underlyingType = object.getJSONObject("fields").getJSONObject("value__").getString("type");
				}
			} else {
				underlyingType = "";
			}

			if (object.has("fields")) {
				var classFields = object.getJSONObject("fields");
				for (var fieldName : classFields.keySet()) {
					fields.add(new REField(fieldName, classFields.getJSONObject(fieldName)));
				}
			}

			if (object.has("methods")) {
				var classMethods = object.getJSONObject("methods");
				for (var methodName : classMethods.keySet()) {
					REMethod method = new REMethod(methodName, classMethods.getJSONObject(methodName));
					if (isValueType) {
						method.setReturnAsOutParameter();
					}

					methods.add(method);
				}
			}
		}

		public String getName() {
			return name;
		}

		public int getSize() {
			return size;
		}

		public boolean hasParent() {
			return !parent.isEmpty();
		}

		public String getParent() {
			return parent;
		}

		public boolean isEnum() {
			return isEnum;
		}

		public String getUnderlyingType() {
			return underlyingType;
		}

		public boolean hasFields() {
			return !fields.isEmpty();
		}

		public boolean hasMethods() {
			return !methods.isEmpty();
		}

		public ArrayList<REField> getFields() {
			return fields;
		}

		public ArrayList<REMethod> getMethods() {
			return methods;
		}

		public boolean isValueType() {
			return isValueType;
		}

		public DataType getDataType() {
			return dataType;
		}

		public DataType getPointerTo() {
			return pointerTo;
		}

		public void setDataType(DataType type) {
			dataType = type;
			pointerTo = new PointerDataType(type, 8);
		}
	}
}
